#ifndef __ASF_UTILS__
#define __ASF_UTILS__

#include <asf-namespace.h>
#include <sdf-namespace.h>
#include <term-namespace.h>
#include <error-support.idef>
#include <sdf-renaming.idef>
#include <asfoperations.idef>
#include <asfe.idef>
#include <asfc.idef>
#include <asfchecker.idef>
#include <term-utils.tb>
#include <sdf-utils.tb>
#include <asfsdfchecker.idef>
#include <cache-utils.tb>
#include <attribute-changed-event.tb>
#include <module-utils.tb>

#define ASF_TREE_CACHE "asf-annotated-tree"
#define ASF_NORMALIZED_TREE_CACHE "asf-normalized-tree"

process AsfPath2SdfPath(AsfPath : str, SdfPath : str?) is
  ReplaceExtension(AsfPath, SDF_EXTENSION, SdfPath?)
  
process SdfPath2AsfPath(SdfPath : str, AsfPath : str?) is
  ReplaceExtension(SdfPath, ASF_EXTENSION, AsfPath?)
  
/* RegisterASFModule forges the link between an ASF and an SDF module.
 * It reuses the same module Id, and constructs an ASF path from
 * a SDF path.
 */
process RegisterASFModule(ModuleId: module-id) is
let
  AsfPath: str,
  Modulename: str,
  SdfPath: str,
  SdfModuleId: module-id
in
  GetModulePath(ModuleId, ASF_NAMESPACE, AsfPath?)
  . printf("Asf path: %t\n", AsfPath)
  . AsfPath2SdfPath(AsfPath, SdfPath?)
  . printf("Sdf path: %t\n", SdfPath)
  . GetOrCreateModule(SDF_NAMESPACE, SdfPath, SdfModuleId?)
  . MM-SetAttribute(SdfModuleId, ASF_NAMESPACE, "path", path(AsfPath))
  . MM-SetAttribute(ModuleId, ASF_NAMESPACE, "path", path(AsfPath))
  . MM-GetAttribute(SdfModuleId, SDF_NAMESPACE, "name", Modulename?)
  . MM-SetAttribute(SdfModuleId, ASF_NAMESPACE, "name", Modulename)
  . MM-SetAttribute(ModuleId, ASF_NAMESPACE, "sdf-id", SdfModuleId)
  . MM-SetAttribute(SdfModuleId, ASF_NAMESPACE, "sdf-id", SdfModuleId)
  . printf("registered sdf-id for %t (%t)\n", ModuleId, SdfModuleId)
  . MM-SetAttribute(SdfModuleId, ASF_NAMESPACE, "status", dirty)
  . MM-SetAttribute(ModuleId, SDF_NAMESPACE, "status", linked)
endlet



process Asf2SdfId(AsfModuleId: module-id, SdfModuleId: module-id?) is
  MM-GetAttribute(AsfModuleId, ASF_NAMESPACE, "sdf-id", SdfModuleId?)
  
process GetASFModuleId(Filename : str, ModuleId : module-id?) is
  GetOrCreateModule(ASF_NAMESPACE, Filename, ModuleId?)

process OpenASFModule(ModuleId: module-id) is
let
  AsfPath: str,
  Editable: bool,
  LibraryModule: bool
in
  GetModulePath(ModuleId, ASF_NAMESPACE, AsfPath?)
  . snd-msg(io-exists-file(AsfPath))
  .
  (
    rec-msg(io-file-exists)
    . IsLibraryModule(ModuleId, LibraryModule?)
    . Editable := not(LibraryModule)
    . MM-SetAttribute(ModuleId, ASF_NAMESPACE, "editable", Editable)
    . MM-SetAttribute(ModuleId, ASF_NAMESPACE, "status", dirty)
  +
    rec-msg(io-file-not-exists)
    . MM-SetAttribute(ModuleId, ASF_NAMESPACE, "status", unavailable)
  )
endlet

process CheckASFSDFSyntax(ModuleId : module-id) is
let
  Syntax: term,
  Feedback: term,
  Modulename: str,
  Summary: summary,
  Errors: list
in
  AddJob("Checking syntax definition") 
  . snd-msg(tm-request-transaction(syntax-definition))
  . GetSyntaxDefinition(ModuleId, Syntax?)
  . snd-msg(tm-end-transaction(syntax-definition))
  .
  if not-equal(Syntax, UNDEFINED) then
    MM-GetAttribute(ModuleId, SDF_NAMESPACE, "name", Modulename?)
    . snd-msg(check-asfsdf(Syntax, Modulename)) 
    . rec-msg(checked-asfsdf(Feedback?)) 
    . snd-msg(convert-feedback(Feedback)) 
    . rec-msg(converted-feedback(Summary?)) 
    . ReplaceSummaryInfo(Summary?, "asfsdf-checker", Modulename)
    . RemoveSummary("asfsdf-checker", Modulename)
    . DisplaySummary(Summary)
    . Syntax := UNDEFINED
  else
    tau
  fi
  . JobDone("Checking syntax definition") 
endlet

process CheckASFModule(ModuleId: module-id) is
let
  Summary : summary,
  Errors: list,
  Modulename: str,
  Tree: term
in
  GetASFParseTree(ModuleId, Tree?)
  .
  if not-equal(Tree, UNDEFINED) then
    snd-msg(check-asf(Tree))
    . rec-msg(messages(Errors?))
    . MM-GetAttribute(ModuleId, ASF_NAMESPACE, "name", Modulename?) 
    . RemoveSummary("asf-checker", Modulename)
    . snd-msg(es-make-summary("asf-checker", Modulename, Errors))
    . rec-msg(es-summary(Summary?))
    . DisplaySummary(Summary)
  else
    tau
  fi
endlet

/* TODO: ensure cache is initialized before first call */
toolbus(InitCache(ASF_TREE_CACHE))
toolbus(ClearCacheHandler(ASF_TREE_CACHE, ASF_NAMESPACE, "status", <term>,dirty))
toolbus(ClearCacheHandler(ASF_TREE_CACHE, SDF_NAMESPACE, "status", <term>,complete))

process GetASFParseTree(ModuleId: module-id, Result: term?) is
let
  AmbPid: int,
  ParseTable: term,
  SdfPath: str,
  AsfPath: str,
  Pid: int,
  Text: str,
  Type: str,
  Tree: term
in
  snd-msg(tm-request-transaction(asf-parsing))
  . GetCachedValue(ASF_TREE_CACHE, ModuleId, Tree?)
  .
  if equal(Tree, UNDEFINED) then
    Type := ASF_NAMESPACE
    . GetModulePath(ModuleId, SDF_NAMESPACE, SdfPath?)
    . SdfPath2AsfPath(SdfPath, AsfPath?)
    . ReadText(AsfPath, Text?)
    .
    if not-equal(Text, "") then
      printf("Getting parse table %t %t\n", ModuleId, Type)
      . GetParseTable(ModuleId, Type, ParseTable?)
      .
      if not-equal(ParseTable, UNDEFINED) then
        create(ParseTreeHandler(ModuleId, AsfPath), Pid?)
	    . RemoveAmbiguitySummary(AsfPath)
	    . printf("ParseText for ASF equations: %s\n", Text)
        . ParseText(Pid, Text, ParseTable, ASF_TOPSORT, on)
        .
        (
          rec-msg(parse-handler-done(Pid, ModuleId, Tree?))
	      . create(AmbiguityHandler(Tree, AsfPath), AmbPid?)
          . AnnotateTree(Tree, AsfPath, Result?) 
          . PutCachedValue(ASF_TREE_CACHE, ModuleId, Result)
        +
          rec-msg(parse-handler-done(Pid))
          . Result := UNDEFINED
        )
      else 
        Result := UNDEFINED
      fi
    else
      Result := UNDEFINED
    fi
  else
    Result := Tree
  fi 
  . snd-msg(tm-end-transaction(asf-parsing))
endlet

process RunCompiler(Modulename: str, Table: term, Equations: term, OutputFile: str ) is
let
  Progress : str,
  Id : int
in
  Id := process-id
  . subscribe(asfc-progress(<term>))
  . snd-msg(compile-module(Modulename, OutputFile, Equations, Table)) .
  (
    rec-note(asfc-progress(Progress?)).
    snd-note(ui-status(endstat(Id))).
    snd-note(ui-status(statf(Id,"Compiling %s - %s", [Modulename, Progress])))
  )
  *
  rec-msg(compilation-done(Modulename))
endlet

process CompileModule(ModuleId : module-id, OutputFile: str) is
let
  Equations: term,
  Error: str,
  Id: term,
  Pid: int,
  Specification: term,
  Table: term,
  Modulename: str
in
   AddJob("Compiling")
   . GetSpecification(ModuleId, Specification?)
   .
   if not-equal(Specification, UNDEFINED) then
     GetSpecificationEquations(Specification, Equations?)
     . GetParseTable(ModuleId, TERM_NAMESPACE, Table?)
     .
     if not-equal(Table, UNDEFINED) then
       MM-GetAttribute(ModuleId, SDF_NAMESPACE, "name", Modulename?)
       . RunCompiler(Modulename, Table, Equations, OutputFile)   
     else
       snd-note(ui-status(statf(Id, "Specification could not be compiled")))
     fi
   else
     snd-note(ui-status(statf(Id, "Specification could not be compiled")))
     . snd-note(ui-status(stop(Id)))
   fi
   . JobDone("Compiling")
endlet

process DumpEquations(ModuleId: module-id) is
let
  SdfPath: str,
  Path : str
in
  GetModulePath(ModuleId, SDF_NAMESPACE, SdfPath?)
  . ReplaceExtension(SdfPath, ".eqs", Path?)
  . DumpEquationsGivenFile(ModuleId, Path)
endlet

process DumpTestEquationsGivenFile(ModuleId : module-id, Path: str) is
let
  Equations: term,
  Error: term,
  Filename: str,
  Id: int,
  Pid: int,
  Specification: term
in
  AddJob("Dumping tests...")
  . GetSpecification(ModuleId, Specification?)
  .
  if not-equal(Specification, UNDEFINED) then
    GetSpecificationTests(Specification, Equations?)
    . snd-msg(io-unpack-and-write-term-in-baf(Path, Equations))
    .
    (
      rec-msg(io-file-written)
    +
      rec-msg(io-file-not-written(Error?))
      . snd-note(ui-status(errorf("%s: %t", [Path, Error])))
    )
  else   
     snd-note(ui-status(statf(Id, "Specification could not be dumped")))
  fi
  . snd-note(ui-status(stop(Id)))
  . JobDone("Dumping tests...")
endlet


process DumpEquationsGivenFile(ModuleId : module-id, Path: str) is
let
  Equations: term,
  Error: term,
  Filename: str,
  Id: int,
  Pid: int,
  Specification: term
in
  AddJob("Dumping equations...")
  . GetSpecification(ModuleId, Specification?)
  .
  if not-equal(Specification, UNDEFINED) then
    GetSpecificationEquations(Specification, Equations?)
    . snd-msg(io-unpack-and-write-term-in-baf(Path, Equations))
    .
    (
      rec-msg(io-file-written)
    +
      rec-msg(io-file-not-written(Error?))
      . snd-note(ui-status(errorf("%s: %t", [Path, Error])))
    )
  else   
     snd-note(ui-status(statf(Id, "Specification could not be dumped")))
  fi
  . snd-note(ui-status(stop(Id)))
  . JobDone("Dumping equations...")
endlet

toolbus(InitCache(ASF_NORMALIZED_TREE_CACHE))
toolbus(ClearCacheHandler(ASF_NORMALIZED_TREE_CACHE, ASF_NAMESPACE, "status", <term>,available))
toolbus(ClearCacheHandler(ASF_NORMALIZED_TREE_CACHE, SDF_NAMESPACE, "status", <term>,complete))

process NormalizeEquations(ModuleId : term, Equations: term, Result : term?) is
let
  Tree : term
in
  Tree := UNDEFINED
  . GetCachedValue(ASF_NORMALIZED_TREE_CACHE, ModuleId, Tree?)
  .
  if not-equal(Tree, UNDEFINED) then
    Result := Tree
  else
    AddJob("Normalizing ...")
    . snd-msg(ao-normalize-module(Equations)) 
    . rec-msg(ao-normalize-module-result(Tree?))
    . PutCachedValue(ASF_NORMALIZED_TREE_CACHE, ModuleId, Tree)
    . Result := Tree
    . JobDone("Normalizing ...")
  fi 
endlet

process RenameEquations(Modulename: str, Imports : list, Equations : term,
                        Result : term?)
is
  AddJob("Renaming ...")
  . snd-msg(sr-rename-module(Imports, Modulename, Equations))
  . rec-msg(sr-renamed-module(Result?))
  . JobDone("Renaming ...")

process GetSpecification(ModuleId: module-id, Result: term?) is
let
  Error: term,
  CurModule: module-id,
  Equations: term,
  NormalizedEquations: term,
  RenamedEquations: term,
  Imports: list,
  Modulename: str,
  Modules: list,
  Opened: bool,
  Pid: int,
  Specification: term,
  Id : int,
  Count : int,
  Done : int
in
  Id := process-id
  . snd-note(ui-status(start(Id, "Get Specification")))
  . AddJob("Collecting and normalizing specification")
  . MM-GetAllModuleDependencies(ModuleId, Modules?)
  . Modules := join([ModuleId], Modules)
  . GetImportsForRenaming(ModuleId, Modules, Imports?)
  . Count := size(Modules)
  . Specification := []
  . 
  if and(not-equal(Modules, []), equal(Error, undefined)) then
    CurModule := first(Modules)
    . GetASFParseTree(CurModule, Equations?)
    .
    if equal(Equations, UNDEFINED) then
      tau
    else
    /* normalization should occur BEFORE renaming 
     * proposal: merge the renaming and normalization tools,
     * possibly including the get-imports tool. 
     */
      MM-GetAttribute(CurModule, SDF_NAMESPACE, "name", Modulename?)
      . NormalizeEquations(CurModule, Equations, NormalizedEquations?)
      . RenameEquations(Modulename, Imports, NormalizedEquations, RenamedEquations?)
      . Specification := join(Specification, RenamedEquations)
      . MM-SetAttribute(CurModule, ASF_NAMESPACE, "status", complete)
    fi
    . Modules := next(Modules)
    . Done := sub(Count, size(Modules))
  fi
  *
  (
    if not-equal(Error, undefined) then
      Result := UNDEFINED
    fi
  +
    if equal(Modules, []) then
      Result := Specification
    fi
  )
  . snd-msg(ao-restart)
  . JobDone("Collecting and normalizing specification")
endlet

process GetSpecificationEquations(Specification: term, Equations: term?) is
  snd-msg(ao-extract-equations(Specification))
  . rec-msg(ao-extract-equations-result(Equations?))

process GetSpecificationTests(Specification: term, Tests: term?) is
  snd-msg(ao-extract-tests(Specification))
  . rec-msg(ao-extract-tests-result(Tests?))

process TestAsfSpecification(ModuleId: module-id, Debugging: term) is
let
  Specification : term,
  Equations : term,
  ParseTable : term,
  Tests : term,
  Id : int,
  Pid : int,
  Errors : list,
  Summary: summary,
  Modulename: str
in
  AddJob("Testing ASF Specification")
  . snd-note(ui-status(stat(Id, "Retrieving equations and tests"))) 
  . GetSpecification(ModuleId, Specification?)
  .
  if not-equal(Specification, UNDEFINED) then
    GetSpecificationEquations(Specification, Equations?) 
    . GetSpecificationTests(Specification, Tests?) 
    . GetTermParseTable(ModuleId, ParseTable?)
    . snd-note(ui-status(endstat(Id))) 
    . snd-note(ui-status(stat(Id, "Running tests"))) 
    . snd-msg(asfe-run-tests(Equations, Tests, ParseTable, Debugging)) 
    .
    (
      rec-msg(asfe-test-results(Errors?)) 
      . MM-GetAttribute(ModuleId, SDF_NAMESPACE, "name", Modulename?)
      . RemoveSummary("asf-tests",Modulename)
      .
      if equal(Errors, []) then
        snd-msg(show-message-dialog("All tests succeeded"))
      else
        snd-msg(es-make-summary("asf-tests", Modulename, Errors))
        . rec-msg(es-summary(Summary?))
        . DisplaySummary(Summary)
      fi
    +
      rec-msg(asfe-rewrite-errors(Errors?))
      . RemoveSummary("asfe", "all")
      . snd-msg(es-make-summary("asfe", "all", Errors)) 
      . rec-msg(es-summary(Summary?)) 
      . DisplaySummary(Summary)
    ) 
    . snd-note(ui-status(endstat(Id))) 
  else
    TODO("Summary is undefined here!\n")
    . DisplaySummary(Summary)
    . snd-note(ui-status(endstat(Id))) 
    . snd-note(ui-status(errorf("Equations incomplete for %s", [Modulename])))
  fi
  . JobDone("Testing ASF Specification")
endlet

process ReduceTerm(Tree: term, ModuleId: module-id, Debugging: term, NormalForm: term?) is
let
  Summary: summary,
  Equations: term,
  Id: int,
  Modulename: str,
  Pid: int,
  Specification: term,
  Text: str,
  Errors: list,
  ParseTable: term,
  NormalFormWithoutBrackets: term
in
  Id := process-id
  . GetSpecification(ModuleId, Specification?)
  .
  if not-equal(Specification, UNDEFINED) then
    GetSpecificationEquations(Specification, Equations?)
    . GetTermParseTable(ModuleId, ParseTable?)
    . AddJob("Rewriting...")
    . MM-GetAttribute(ModuleId, SDF_NAMESPACE, "name", Modulename?)
    . snd-msg(asfe-rewrite(Modulename, Equations, ParseTable, Tree, Debugging))
    .
    (
      rec-msg(asfe-rewrite-result(NormalFormWithoutBrackets?))
      . RestoreTermBrackets(ModuleId, NormalFormWithoutBrackets, NormalForm?)
      . RemoveSummary("asfe", "all")
    +
      rec-msg(asfe-rewrite-result-with-errors(NormalFormWithoutBrackets?,Errors?))
      . RemoveSummary("asfe", "all")
      . snd-msg(es-make-summary("asfe", "all", Errors)) 
      . rec-msg(es-summary(Summary?)) 
      . DisplaySummary(Summary)
      . RestoreTermBrackets(ModuleId, NormalFormWithoutBrackets, NormalForm?)
    +
      rec-msg(asfe-rewrite-errors(Errors?))
      . RemoveSummary("asfe", "all")
      . snd-msg(es-make-summary("asfe", "all", Errors)) 
      . rec-msg(es-summary(Summary?)) 
      . DisplaySummary(Summary)
    )
    . JobDone("Rewriting...")
  else
    NormalForm := UNDEFINED
  fi
endlet

process Reduce(ModuleId : module-id, Path : str, Debugging: term, Tree: term?) is
let
  Parsetree: term,
  ResultTree: term
in
  GetTermParsetree(ModuleId, Path, Parsetree?)
  . Tree := UNDEFINED
  .
  if not-equal(Parsetree, UNDEFINED) then 
    ReduceTerm(Parsetree, ModuleId, Debugging, ResultTree?)
    .
    if not-equal(ResultTree, UNDEFINED) then
      snd-msg(promote-posinfo-to-origin(ResultTree))
      . rec-msg(promoted-posinfo-to-origin(ResultTree?))
      . AnnotateTree(ResultTree, "reduct.out", Tree?)
    else
      tau
    fi
  else
    tau
  fi
endlet

#endif /* __ASF_UTILS__ */

